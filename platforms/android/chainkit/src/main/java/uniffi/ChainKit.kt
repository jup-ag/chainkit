// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

@file:Suppress("NAME_SHADOWING")

package uniffi;

// Common helper code.
//
// Ideally this would live in a separate .kt file where it can be unittested etc
// in isolation, and perhaps even published as a re-useable package.
//
// However, it's important that the details of how this helper code works (e.g. the
// way that different builtin types are passed across the FFI) exactly match what's
// expected by the Rust code on the other side of the interface. In practice right
// now that means coming from the exact some version of `uniffi` that was used to
// compile the Rust component. The easiest way to ensure this is to bundle the Kotlin
// helpers directly inline like we're doing here.

import com.sun.jna.Library
import com.sun.jna.IntegerType
import com.sun.jna.Native
import com.sun.jna.Pointer
import com.sun.jna.Structure
import com.sun.jna.Callback
import com.sun.jna.ptr.*
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.CharBuffer
import java.nio.charset.CodingErrorAction
import java.util.concurrent.ConcurrentHashMap

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

@Structure.FieldOrder("capacity", "len", "data")
open class RustBuffer : Structure() {
    @JvmField var capacity: Int = 0
    @JvmField var len: Int = 0
    @JvmField var data: Pointer? = null

    class ByValue: RustBuffer(), Structure.ByValue
    class ByReference: RustBuffer(), Structure.ByReference

    companion object {
        internal fun alloc(size: Int = 0) = uniffiRustCall() { status ->
            UniffiLib.INSTANCE.ffi_chainkit_rustbuffer_alloc(size, status)
        }.also {
            if(it.data == null) {
               throw RuntimeException("RustBuffer.alloc() returned null data pointer (size=${size})")
           }
        }

        internal fun create(capacity: Int, len: Int, data: Pointer?): RustBuffer.ByValue {
            var buf = RustBuffer.ByValue()
            buf.capacity = capacity
            buf.len = len
            buf.data = data
            return buf
        }

        internal fun free(buf: RustBuffer.ByValue) = uniffiRustCall() { status ->
            UniffiLib.INSTANCE.ffi_chainkit_rustbuffer_free(buf, status)
        }
    }

    @Suppress("TooGenericExceptionThrown")
    fun asByteBuffer() =
        this.data?.getByteBuffer(0, this.len.toLong())?.also {
            it.order(ByteOrder.BIG_ENDIAN)
        }
}

/**
 * The equivalent of the `*mut RustBuffer` type.
 * Required for callbacks taking in an out pointer.
 *
 * Size is the sum of all values in the struct.
 */
class RustBufferByReference : ByReference(16) {
    /**
     * Set the pointed-to `RustBuffer` to the given value.
     */
    fun setValue(value: RustBuffer.ByValue) {
        // NOTE: The offsets are as they are in the C-like struct.
        val pointer = getPointer()
        pointer.setInt(0, value.capacity)
        pointer.setInt(4, value.len)
        pointer.setPointer(8, value.data)
    }

    /**
     * Get a `RustBuffer.ByValue` from this reference.
     */
    fun getValue(): RustBuffer.ByValue {
        val pointer = getPointer()
        val value = RustBuffer.ByValue()
        value.writeField("capacity", pointer.getInt(0))
        value.writeField("len", pointer.getInt(4))
        value.writeField("data", pointer.getPointer(8))

        return value
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to in the JVM, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

@Structure.FieldOrder("len", "data")
open class ForeignBytes : Structure() {
    @JvmField var len: Int = 0
    @JvmField var data: Pointer? = null

    class ByValue : ForeignBytes(), Structure.ByValue
}
// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
public interface FfiConverter<KotlinType, FfiType> {
    // Convert an FFI type to a Kotlin type
    fun lift(value: FfiType): KotlinType

    // Convert an Kotlin type to an FFI type
    fun lower(value: KotlinType): FfiType

    // Read a Kotlin type from a `ByteBuffer`
    fun read(buf: ByteBuffer): KotlinType

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    fun allocationSize(value: KotlinType): Int

    // Write a Kotlin type to a `ByteBuffer`
    fun write(value: KotlinType, buf: ByteBuffer)

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    fun lowerIntoRustBuffer(value: KotlinType): RustBuffer.ByValue {
        val rbuf = RustBuffer.alloc(allocationSize(value))
        try {
            val bbuf = rbuf.data!!.getByteBuffer(0, rbuf.capacity.toLong()).also {
                it.order(ByteOrder.BIG_ENDIAN)
            }
            write(value, bbuf)
            rbuf.writeField("len", bbuf.position())
            return rbuf
        } catch (e: Throwable) {
            RustBuffer.free(rbuf)
            throw e
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    fun liftFromRustBuffer(rbuf: RustBuffer.ByValue): KotlinType {
        val byteBuf = rbuf.asByteBuffer()!!
        try {
           val item = read(byteBuf)
           if (byteBuf.hasRemaining()) {
               throw RuntimeException("junk remaining in buffer after lifting, something is very wrong!!")
           }
           return item
        } finally {
            RustBuffer.free(rbuf)
        }
    }
}

// FfiConverter that uses `RustBuffer` as the FfiType
public interface FfiConverterRustBuffer<KotlinType>: FfiConverter<KotlinType, RustBuffer.ByValue> {
    override fun lift(value: RustBuffer.ByValue) = liftFromRustBuffer(value)
    override fun lower(value: KotlinType) = lowerIntoRustBuffer(value)
}
// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.
@Structure.FieldOrder("code", "error_buf")
internal open class UniffiRustCallStatus : Structure() {
    @JvmField var code: Byte = 0
    @JvmField var error_buf: RustBuffer.ByValue = RustBuffer.ByValue()

    class ByValue: UniffiRustCallStatus(), Structure.ByValue

    fun isSuccess(): Boolean {
        return code == 0.toByte()
    }

    fun isError(): Boolean {
        return code == 1.toByte()
    }

    fun isPanic(): Boolean {
        return code == 2.toByte()
    }
}

class InternalException(message: String) : Exception(message)

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface UniffiRustCallStatusErrorHandler<E> {
    fun lift(error_buf: RustBuffer.ByValue): E;
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself

// Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
private inline fun <U, E: Exception> uniffiRustCallWithError(errorHandler: UniffiRustCallStatusErrorHandler<E>, callback: (UniffiRustCallStatus) -> U): U {
    var status = UniffiRustCallStatus();
    val return_value = callback(status)
    uniffiCheckCallStatus(errorHandler, status)
    return return_value
}

// Check UniffiRustCallStatus and throw an error if the call wasn't successful
private fun<E: Exception> uniffiCheckCallStatus(errorHandler: UniffiRustCallStatusErrorHandler<E>, status: UniffiRustCallStatus) {
    if (status.isSuccess()) {
        return
    } else if (status.isError()) {
        throw errorHandler.lift(status.error_buf)
    } else if (status.isPanic()) {
        // when the rust code sees a panic, it tries to construct a rustbuffer
        // with the message.  but if that code panics, then it just sends back
        // an empty buffer.
        if (status.error_buf.len > 0) {
            throw InternalException(FfiConverterString.lift(status.error_buf))
        } else {
            throw InternalException("Rust panic")
        }
    } else {
        throw InternalException("Unknown rust call status: $status.code")
    }
}

// UniffiRustCallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
object UniffiNullRustCallStatusErrorHandler: UniffiRustCallStatusErrorHandler<InternalException> {
    override fun lift(error_buf: RustBuffer.ByValue): InternalException {
        RustBuffer.free(error_buf)
        return InternalException("Unexpected CALL_ERROR")
    }
}

// Call a rust function that returns a plain value
private inline fun <U> uniffiRustCall(callback: (UniffiRustCallStatus) -> U): U {
    return uniffiRustCallWithError(UniffiNullRustCallStatusErrorHandler, callback);
}

// IntegerType that matches Rust's `usize` / C's `size_t`
public class USize(value: Long = 0) : IntegerType(Native.SIZE_T_SIZE, value, true) {
    // This is needed to fill in the gaps of IntegerType's implementation of Number for Kotlin.
    override fun toByte() = toInt().toByte()
    // Needed until https://youtrack.jetbrains.com/issue/KT-47902 is fixed.
    @Deprecated("`toInt().toChar()` is deprecated")
    override fun toChar() = toInt().toChar()
    override fun toShort() = toInt().toShort()

    fun writeToBuffer(buf: ByteBuffer) {
        // Make sure we always write usize integers using native byte-order, since they may be
        // casted to pointer values
        buf.order(ByteOrder.nativeOrder())
        try {
            when (Native.SIZE_T_SIZE) {
                4 -> buf.putInt(toInt())
                8 -> buf.putLong(toLong())
                else -> throw RuntimeException("Invalid SIZE_T_SIZE: ${Native.SIZE_T_SIZE}")
            }
        } finally {
            buf.order(ByteOrder.BIG_ENDIAN)
        }
    }

    companion object {
        val size: Int
            get() = Native.SIZE_T_SIZE

        fun readFromBuffer(buf: ByteBuffer) : USize {
            // Make sure we always read usize integers using native byte-order, since they may be
            // casted from pointer values
            buf.order(ByteOrder.nativeOrder())
            try {
                return when (Native.SIZE_T_SIZE) {
                    4 -> USize(buf.getInt().toLong())
                    8 -> USize(buf.getLong())
                    else -> throw RuntimeException("Invalid SIZE_T_SIZE: ${Native.SIZE_T_SIZE}")
                }
            } finally {
                buf.order(ByteOrder.BIG_ENDIAN)
            }
        }
    }
}


// Map handles to objects
//
// This is used when the Rust code expects an opaque pointer to represent some foreign object.
// Normally we would pass a pointer to the object, but JNA doesn't support getting a pointer from an
// object reference , nor does it support leaking a reference to Rust.
//
// Instead, this class maps USize values to objects so that we can pass a pointer-sized type to
// Rust when it needs an opaque pointer.
//
// TODO: refactor callbacks to use this class
internal class UniFfiHandleMap<T: Any> {
    private val map = ConcurrentHashMap<USize, T>()
    // Use AtomicInteger for our counter, since we may be on a 32-bit system.  4 billion possible
    // values seems like enough. If somehow we generate 4 billion handles, then this will wrap
    // around back to zero and we can assume the first handle generated will have been dropped by
    // then.
    private val counter = java.util.concurrent.atomic.AtomicInteger(0)

    val size: Int
        get() = map.size

    fun insert(obj: T): USize {
        val handle = USize(counter.getAndAdd(1).toLong())
        map.put(handle, obj)
        return handle
    }

    fun get(handle: USize): T? {
        return map.get(handle)
    }

    fun remove(handle: USize): T? {
        return map.remove(handle)
    }
}

// FFI type for Rust future continuations
internal interface UniFffiRustFutureContinuationCallbackType : com.sun.jna.Callback {
    fun callback(continuationHandle: USize, pollResult: Byte);
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.
@Synchronized
private fun findLibraryName(componentName: String): String {
    val libOverride = System.getProperty("uniffi.component.$componentName.libraryOverride")
    if (libOverride != null) {
        return libOverride
    }
    return "uniffi_ChainKit"
}

private inline fun <reified Lib : Library> loadIndirect(
    componentName: String
): Lib {
    return Native.load<Lib>(findLibraryName(componentName), Lib::class.java)
}

// A JNA Library to expose the extern-C FFI definitions.
// This is an implementation detail which will be called internally by the public API.

internal interface UniffiLib : Library {
    companion object {
        internal val INSTANCE: UniffiLib by lazy {
            loadIndirect<UniffiLib>(componentName = "ChainKit")
            .also { lib: UniffiLib ->
                uniffiCheckContractApiVersion(lib)
                uniffiCheckApiChecksums(lib)
                }
        }
        
    }

    fun uniffi_chainkit_fn_func_append_signature_to_transaction(`signer`: RustBuffer.ByValue,`signature`: RustBuffer.ByValue,`transaction`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_chainkit_fn_func_decrypt_ciphertext(`ciphertext`: RustBuffer.ByValue,`password`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_chainkit_fn_func_derive(`chain`: RustBuffer.ByValue,`mnemonic`: RustBuffer.ByValue,`passphrase`: RustBuffer.ByValue,`derivation`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_chainkit_fn_func_derive_from_data(`chain`: RustBuffer.ByValue,`data`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_chainkit_fn_func_encrypt_plaintext(`plaintext`: RustBuffer.ByValue,`password`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_chainkit_fn_func_generate_mnemonic(`length`: Int,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_chainkit_fn_func_get_associated_token_address(`walletAddress`: RustBuffer.ByValue,`ownerProgram`: RustBuffer.ByValue,`tokenMintAddress`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_chainkit_fn_func_get_message(`transaction`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_chainkit_fn_func_get_program_address(`seeds`: RustBuffer.ByValue,`program`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_chainkit_fn_func_is_valid(`chain`: RustBuffer.ByValue,`address`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun uniffi_chainkit_fn_func_modify_transaction(`chain`: RustBuffer.ByValue,`transaction`: RustBuffer.ByValue,`owner`: RustBuffer.ByValue,`parameters`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_chainkit_fn_func_parse_private_key(`key`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_chainkit_fn_func_parse_public_key(`address`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_chainkit_fn_func_parse_transaction(`chain`: RustBuffer.ByValue,`transaction`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_chainkit_fn_func_raw_private_key(`chain`: RustBuffer.ByValue,`key`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_chainkit_fn_func_send_transaction(`chain`: RustBuffer.ByValue,`sender`: RustBuffer.ByValue,`receiver`: RustBuffer.ByValue,`amount`: RustBuffer.ByValue,`parameters`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_chainkit_fn_func_sign_message(`chain`: RustBuffer.ByValue,`message`: RustBuffer.ByValue,`signers`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_chainkit_fn_func_sign_transaction(`chain`: RustBuffer.ByValue,`transaction`: RustBuffer.ByValue,`signers`: RustBuffer.ByValue,`parameters`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_chainkit_fn_func_sign_typed_data(`chain`: RustBuffer.ByValue,`typedData`: RustBuffer.ByValue,`signers`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun uniffi_chainkit_fn_func_token_transaction(`chain`: RustBuffer.ByValue,`destination`: RustBuffer.ByValue,`owner`: RustBuffer.ByValue,`token`: RustBuffer.ByValue,`kind`: RustBuffer.ByValue,`parameters`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_chainkit_rustbuffer_alloc(`size`: Int,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_chainkit_rustbuffer_from_bytes(`bytes`: ForeignBytes.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_chainkit_rustbuffer_free(`buf`: RustBuffer.ByValue,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun ffi_chainkit_rustbuffer_reserve(`buf`: RustBuffer.ByValue,`additional`: Int,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_chainkit_rust_future_poll_u8(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_chainkit_rust_future_cancel_u8(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_free_u8(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_complete_u8(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun ffi_chainkit_rust_future_poll_i8(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_chainkit_rust_future_cancel_i8(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_free_i8(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_complete_i8(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Byte
    fun ffi_chainkit_rust_future_poll_u16(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_chainkit_rust_future_cancel_u16(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_free_u16(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_complete_u16(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Short
    fun ffi_chainkit_rust_future_poll_i16(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_chainkit_rust_future_cancel_i16(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_free_i16(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_complete_i16(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Short
    fun ffi_chainkit_rust_future_poll_u32(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_chainkit_rust_future_cancel_u32(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_free_u32(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_complete_u32(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Int
    fun ffi_chainkit_rust_future_poll_i32(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_chainkit_rust_future_cancel_i32(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_free_i32(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_complete_i32(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Int
    fun ffi_chainkit_rust_future_poll_u64(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_chainkit_rust_future_cancel_u64(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_free_u64(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_complete_u64(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Long
    fun ffi_chainkit_rust_future_poll_i64(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_chainkit_rust_future_cancel_i64(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_free_i64(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_complete_i64(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Long
    fun ffi_chainkit_rust_future_poll_f32(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_chainkit_rust_future_cancel_f32(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_free_f32(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_complete_f32(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Float
    fun ffi_chainkit_rust_future_poll_f64(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_chainkit_rust_future_cancel_f64(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_free_f64(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_complete_f64(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Double
    fun ffi_chainkit_rust_future_poll_pointer(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_chainkit_rust_future_cancel_pointer(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_free_pointer(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_complete_pointer(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Pointer
    fun ffi_chainkit_rust_future_poll_rust_buffer(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_chainkit_rust_future_cancel_rust_buffer(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_free_rust_buffer(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_complete_rust_buffer(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): RustBuffer.ByValue
    fun ffi_chainkit_rust_future_poll_void(`handle`: Pointer,`callback`: UniFffiRustFutureContinuationCallbackType,`callbackData`: USize,
    ): Unit
    fun ffi_chainkit_rust_future_cancel_void(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_free_void(`handle`: Pointer,
    ): Unit
    fun ffi_chainkit_rust_future_complete_void(`handle`: Pointer,uniffi_out_err: UniffiRustCallStatus, 
    ): Unit
    fun uniffi_chainkit_checksum_func_append_signature_to_transaction(
    ): Short
    fun uniffi_chainkit_checksum_func_decrypt_ciphertext(
    ): Short
    fun uniffi_chainkit_checksum_func_derive(
    ): Short
    fun uniffi_chainkit_checksum_func_derive_from_data(
    ): Short
    fun uniffi_chainkit_checksum_func_encrypt_plaintext(
    ): Short
    fun uniffi_chainkit_checksum_func_generate_mnemonic(
    ): Short
    fun uniffi_chainkit_checksum_func_get_associated_token_address(
    ): Short
    fun uniffi_chainkit_checksum_func_get_message(
    ): Short
    fun uniffi_chainkit_checksum_func_get_program_address(
    ): Short
    fun uniffi_chainkit_checksum_func_is_valid(
    ): Short
    fun uniffi_chainkit_checksum_func_modify_transaction(
    ): Short
    fun uniffi_chainkit_checksum_func_parse_private_key(
    ): Short
    fun uniffi_chainkit_checksum_func_parse_public_key(
    ): Short
    fun uniffi_chainkit_checksum_func_parse_transaction(
    ): Short
    fun uniffi_chainkit_checksum_func_raw_private_key(
    ): Short
    fun uniffi_chainkit_checksum_func_send_transaction(
    ): Short
    fun uniffi_chainkit_checksum_func_sign_message(
    ): Short
    fun uniffi_chainkit_checksum_func_sign_transaction(
    ): Short
    fun uniffi_chainkit_checksum_func_sign_typed_data(
    ): Short
    fun uniffi_chainkit_checksum_func_token_transaction(
    ): Short
    fun ffi_chainkit_uniffi_contract_version(
    ): Int
    
}

private fun uniffiCheckContractApiVersion(lib: UniffiLib) {
    // Get the bindings contract version from our ComponentInterface
    val bindings_contract_version = 25
    // Get the scaffolding contract version by calling the into the dylib
    val scaffolding_contract_version = lib.ffi_chainkit_uniffi_contract_version()
    if (bindings_contract_version != scaffolding_contract_version) {
        throw RuntimeException("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    }
}

@Suppress("UNUSED_PARAMETER")
private fun uniffiCheckApiChecksums(lib: UniffiLib) {
    if (lib.uniffi_chainkit_checksum_func_append_signature_to_transaction() != 30829.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_chainkit_checksum_func_decrypt_ciphertext() != 29.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_chainkit_checksum_func_derive() != 1524.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_chainkit_checksum_func_derive_from_data() != 63262.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_chainkit_checksum_func_encrypt_plaintext() != 12131.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_chainkit_checksum_func_generate_mnemonic() != 2201.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_chainkit_checksum_func_get_associated_token_address() != 35153.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_chainkit_checksum_func_get_message() != 60832.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_chainkit_checksum_func_get_program_address() != 25842.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_chainkit_checksum_func_is_valid() != 22697.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_chainkit_checksum_func_modify_transaction() != 42466.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_chainkit_checksum_func_parse_private_key() != 20409.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_chainkit_checksum_func_parse_public_key() != 39267.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_chainkit_checksum_func_parse_transaction() != 46478.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_chainkit_checksum_func_raw_private_key() != 30293.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_chainkit_checksum_func_send_transaction() != 14183.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_chainkit_checksum_func_sign_message() != 56256.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_chainkit_checksum_func_sign_transaction() != 3589.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_chainkit_checksum_func_sign_typed_data() != 9261.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
    if (lib.uniffi_chainkit_checksum_func_token_transaction() != 20399.toShort()) {
        throw RuntimeException("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// Async support

// Public interface members begin here.


// Interface implemented by anything that can contain an object reference.
//
// Such types expose a `destroy()` method that must be called to cleanly
// dispose of the contained objects. Failure to call this method may result
// in memory leaks.
//
// The easiest way to ensure this method is called is to use the `.use`
// helper method to execute a block and destroy the object at the end.
interface Disposable {
    fun destroy()
    companion object {
        fun destroy(vararg args: Any?) {
            args.filterIsInstance<Disposable>()
                .forEach(Disposable::destroy)
        }
    }
}

inline fun <T : Disposable?, R> T.use(block: (T) -> R) =
    try {
        block(this)
    } finally {
        try {
            // N.B. our implementation is on the nullable type `Disposable?`.
            this?.destroy()
        } catch (e: Throwable) {
            // swallow
        }
    }

public object FfiConverterUByte: FfiConverter<UByte, Byte> {
    override fun lift(value: Byte): UByte {
        return value.toUByte()
    }

    override fun read(buf: ByteBuffer): UByte {
        return lift(buf.get())
    }

    override fun lower(value: UByte): Byte {
        return value.toByte()
    }

    override fun allocationSize(value: UByte) = 1

    override fun write(value: UByte, buf: ByteBuffer) {
        buf.put(value.toByte())
    }
}

public object FfiConverterUShort: FfiConverter<UShort, Short> {
    override fun lift(value: Short): UShort {
        return value.toUShort()
    }

    override fun read(buf: ByteBuffer): UShort {
        return lift(buf.getShort())
    }

    override fun lower(value: UShort): Short {
        return value.toShort()
    }

    override fun allocationSize(value: UShort) = 2

    override fun write(value: UShort, buf: ByteBuffer) {
        buf.putShort(value.toShort())
    }
}

public object FfiConverterUInt: FfiConverter<UInt, Int> {
    override fun lift(value: Int): UInt {
        return value.toUInt()
    }

    override fun read(buf: ByteBuffer): UInt {
        return lift(buf.getInt())
    }

    override fun lower(value: UInt): Int {
        return value.toInt()
    }

    override fun allocationSize(value: UInt) = 4

    override fun write(value: UInt, buf: ByteBuffer) {
        buf.putInt(value.toInt())
    }
}

public object FfiConverterULong: FfiConverter<ULong, Long> {
    override fun lift(value: Long): ULong {
        return value.toULong()
    }

    override fun read(buf: ByteBuffer): ULong {
        return lift(buf.getLong())
    }

    override fun lower(value: ULong): Long {
        return value.toLong()
    }

    override fun allocationSize(value: ULong) = 8

    override fun write(value: ULong, buf: ByteBuffer) {
        buf.putLong(value.toLong())
    }
}

public object FfiConverterBoolean: FfiConverter<Boolean, Byte> {
    override fun lift(value: Byte): Boolean {
        return value.toInt() != 0
    }

    override fun read(buf: ByteBuffer): Boolean {
        return lift(buf.get())
    }

    override fun lower(value: Boolean): Byte {
        return if (value) 1.toByte() else 0.toByte()
    }

    override fun allocationSize(value: Boolean) = 1

    override fun write(value: Boolean, buf: ByteBuffer) {
        buf.put(lower(value))
    }
}

public object FfiConverterString: FfiConverter<String, RustBuffer.ByValue> {
    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    override fun lift(value: RustBuffer.ByValue): String {
        try {
            val byteArr = ByteArray(value.len)
            value.asByteBuffer()!!.get(byteArr)
            return byteArr.toString(Charsets.UTF_8)
        } finally {
            RustBuffer.free(value)
        }
    }

    override fun read(buf: ByteBuffer): String {
        val len = buf.getInt()
        val byteArr = ByteArray(len)
        buf.get(byteArr)
        return byteArr.toString(Charsets.UTF_8)
    }

    fun toUtf8(value: String): ByteBuffer {
        // Make sure we don't have invalid UTF-16, check for lone surrogates.
        return Charsets.UTF_8.newEncoder().run {
            onMalformedInput(CodingErrorAction.REPORT)
            encode(CharBuffer.wrap(value))
        }
    }

    override fun lower(value: String): RustBuffer.ByValue {
        val byteBuf = toUtf8(value)
        // Ideally we'd pass these bytes to `ffi_bytebuffer_from_bytes`, but doing so would require us
        // to copy them into a JNA `Memory`. So we might as well directly copy them into a `RustBuffer`.
        val rbuf = RustBuffer.alloc(byteBuf.limit())
        rbuf.asByteBuffer()!!.put(byteBuf)
        return rbuf
    }

    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per UTF-16 code unit which will always be
    // enough.
    override fun allocationSize(value: String): Int {
        val sizeForLength = 4
        val sizeForString = value.length * 3
        return sizeForLength + sizeForString
    }

    override fun write(value: String, buf: ByteBuffer) {
        val byteBuf = toUtf8(value)
        buf.putInt(byteBuf.limit())
        buf.put(byteBuf)
    }
}



data class ChainPrivateKey (
    val `contents`: String, 
    val `publicKey`: ChainPublicKey
) {
    
    companion object
}

public object FfiConverterTypeChainPrivateKey: FfiConverterRustBuffer<ChainPrivateKey> {
    override fun read(buf: ByteBuffer): ChainPrivateKey {
        return ChainPrivateKey(
            FfiConverterString.read(buf),
            FfiConverterTypeChainPublicKey.read(buf),
        )
    }

    override fun allocationSize(value: ChainPrivateKey) = (
            FfiConverterString.allocationSize(value.`contents`) +
            FfiConverterTypeChainPublicKey.allocationSize(value.`publicKey`)
    )

    override fun write(value: ChainPrivateKey, buf: ByteBuffer) {
            FfiConverterString.write(value.`contents`, buf)
            FfiConverterTypeChainPublicKey.write(value.`publicKey`, buf)
    }
}



data class ChainPublicKey (
    val `contents`: String, 
    val `chain`: Blockchain
) {
    
    companion object
}

public object FfiConverterTypeChainPublicKey: FfiConverterRustBuffer<ChainPublicKey> {
    override fun read(buf: ByteBuffer): ChainPublicKey {
        return ChainPublicKey(
            FfiConverterString.read(buf),
            FfiConverterTypeBlockchain.read(buf),
        )
    }

    override fun allocationSize(value: ChainPublicKey) = (
            FfiConverterString.allocationSize(value.`contents`) +
            FfiConverterTypeBlockchain.allocationSize(value.`chain`)
    )

    override fun write(value: ChainPublicKey, buf: ByteBuffer) {
            FfiConverterString.write(value.`contents`, buf)
            FfiConverterTypeBlockchain.write(value.`chain`, buf)
    }
}



data class ChainTransaction (
    val `tx`: String, 
    val `signers`: List<ChainPublicKey>, 
    val `fullSignature`: String?, 
    val `signatures`: List<String>?, 
    val `accounts`: List<ChainPublicKey>, 
    val `instructionPrograms`: List<String>
) {
    
    companion object
}

public object FfiConverterTypeChainTransaction: FfiConverterRustBuffer<ChainTransaction> {
    override fun read(buf: ByteBuffer): ChainTransaction {
        return ChainTransaction(
            FfiConverterString.read(buf),
            FfiConverterSequenceTypeChainPublicKey.read(buf),
            FfiConverterOptionalString.read(buf),
            FfiConverterOptionalSequenceString.read(buf),
            FfiConverterSequenceTypeChainPublicKey.read(buf),
            FfiConverterSequenceString.read(buf),
        )
    }

    override fun allocationSize(value: ChainTransaction) = (
            FfiConverterString.allocationSize(value.`tx`) +
            FfiConverterSequenceTypeChainPublicKey.allocationSize(value.`signers`) +
            FfiConverterOptionalString.allocationSize(value.`fullSignature`) +
            FfiConverterOptionalSequenceString.allocationSize(value.`signatures`) +
            FfiConverterSequenceTypeChainPublicKey.allocationSize(value.`accounts`) +
            FfiConverterSequenceString.allocationSize(value.`instructionPrograms`)
    )

    override fun write(value: ChainTransaction, buf: ByteBuffer) {
            FfiConverterString.write(value.`tx`, buf)
            FfiConverterSequenceTypeChainPublicKey.write(value.`signers`, buf)
            FfiConverterOptionalString.write(value.`fullSignature`, buf)
            FfiConverterOptionalSequenceString.write(value.`signatures`, buf)
            FfiConverterSequenceTypeChainPublicKey.write(value.`accounts`, buf)
            FfiConverterSequenceString.write(value.`instructionPrograms`, buf)
    }
}



data class DecimalNumber (
    val `value`: String
) {
    
    companion object
}

public object FfiConverterTypeDecimalNumber: FfiConverterRustBuffer<DecimalNumber> {
    override fun read(buf: ByteBuffer): DecimalNumber {
        return DecimalNumber(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: DecimalNumber) = (
            FfiConverterString.allocationSize(value.`value`)
    )

    override fun write(value: DecimalNumber, buf: ByteBuffer) {
            FfiConverterString.write(value.`value`, buf)
    }
}



data class Derivation (
    val `start`: UInt, 
    val `count`: UInt, 
    val `path`: DerivationPath
) {
    
    companion object
}

public object FfiConverterTypeDerivation: FfiConverterRustBuffer<Derivation> {
    override fun read(buf: ByteBuffer): Derivation {
        return Derivation(
            FfiConverterUInt.read(buf),
            FfiConverterUInt.read(buf),
            FfiConverterTypeDerivationPath.read(buf),
        )
    }

    override fun allocationSize(value: Derivation) = (
            FfiConverterUInt.allocationSize(value.`start`) +
            FfiConverterUInt.allocationSize(value.`count`) +
            FfiConverterTypeDerivationPath.allocationSize(value.`path`)
    )

    override fun write(value: Derivation, buf: ByteBuffer) {
            FfiConverterUInt.write(value.`start`, buf)
            FfiConverterUInt.write(value.`count`, buf)
            FfiConverterTypeDerivationPath.write(value.`path`, buf)
    }
}



data class DerivedPrivateKey (
    val `contents`: String, 
    val `publicKey`: ChainPublicKey, 
    val `index`: UInt
) {
    
    companion object
}

public object FfiConverterTypeDerivedPrivateKey: FfiConverterRustBuffer<DerivedPrivateKey> {
    override fun read(buf: ByteBuffer): DerivedPrivateKey {
        return DerivedPrivateKey(
            FfiConverterString.read(buf),
            FfiConverterTypeChainPublicKey.read(buf),
            FfiConverterUInt.read(buf),
        )
    }

    override fun allocationSize(value: DerivedPrivateKey) = (
            FfiConverterString.allocationSize(value.`contents`) +
            FfiConverterTypeChainPublicKey.allocationSize(value.`publicKey`) +
            FfiConverterUInt.allocationSize(value.`index`)
    )

    override fun write(value: DerivedPrivateKey, buf: ByteBuffer) {
            FfiConverterString.write(value.`contents`, buf)
            FfiConverterTypeChainPublicKey.write(value.`publicKey`, buf)
            FfiConverterUInt.write(value.`index`, buf)
    }
}



data class ExternalAddress (
    val `recentBlockhash`: String
) {
    
    companion object
}

public object FfiConverterTypeExternalAddress: FfiConverterRustBuffer<ExternalAddress> {
    override fun read(buf: ByteBuffer): ExternalAddress {
        return ExternalAddress(
            FfiConverterString.read(buf),
        )
    }

    override fun allocationSize(value: ExternalAddress) = (
            FfiConverterString.allocationSize(value.`recentBlockhash`)
    )

    override fun write(value: ExternalAddress, buf: ByteBuffer) {
            FfiConverterString.write(value.`recentBlockhash`, buf)
    }
}



data class MnemonicWords (
    val `words`: List<String>
) {
    
    companion object
}

public object FfiConverterTypeMnemonicWords: FfiConverterRustBuffer<MnemonicWords> {
    override fun read(buf: ByteBuffer): MnemonicWords {
        return MnemonicWords(
            FfiConverterSequenceString.read(buf),
        )
    }

    override fun allocationSize(value: MnemonicWords) = (
            FfiConverterSequenceString.allocationSize(value.`words`)
    )

    override fun write(value: MnemonicWords, buf: ByteBuffer) {
            FfiConverterSequenceString.write(value.`words`, buf)
    }
}



data class ParsedTransaction (
    val `from`: ChainPublicKey?, 
    val `to`: ChainPublicKey, 
    val `data`: TransactionData
) {
    
    companion object
}

public object FfiConverterTypeParsedTransaction: FfiConverterRustBuffer<ParsedTransaction> {
    override fun read(buf: ByteBuffer): ParsedTransaction {
        return ParsedTransaction(
            FfiConverterOptionalTypeChainPublicKey.read(buf),
            FfiConverterTypeChainPublicKey.read(buf),
            FfiConverterTypeTransactionData.read(buf),
        )
    }

    override fun allocationSize(value: ParsedTransaction) = (
            FfiConverterOptionalTypeChainPublicKey.allocationSize(value.`from`) +
            FfiConverterTypeChainPublicKey.allocationSize(value.`to`) +
            FfiConverterTypeTransactionData.allocationSize(value.`data`)
    )

    override fun write(value: ParsedTransaction, buf: ByteBuffer) {
            FfiConverterOptionalTypeChainPublicKey.write(value.`from`, buf)
            FfiConverterTypeChainPublicKey.write(value.`to`, buf)
            FfiConverterTypeTransactionData.write(value.`data`, buf)
    }
}



enum class Blockchain {
    
    SOLANA;
    companion object
}

public object FfiConverterTypeBlockchain: FfiConverterRustBuffer<Blockchain> {
    override fun read(buf: ByteBuffer) = try {
        Blockchain.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: Blockchain) = 4

    override fun write(value: Blockchain, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}





enum class DerivationPath {
    
    BIP44_ROOT,
    BIP44,
    BIP44_CHANGE,
    DEPRECATED;
    companion object
}

public object FfiConverterTypeDerivationPath: FfiConverterRustBuffer<DerivationPath> {
    override fun read(buf: ByteBuffer) = try {
        DerivationPath.values()[buf.getInt() - 1]
    } catch (e: IndexOutOfBoundsException) {
        throw RuntimeException("invalid enum value, something is very wrong!!", e)
    }

    override fun allocationSize(value: DerivationPath) = 4

    override fun write(value: DerivationPath, buf: ByteBuffer) {
        buf.putInt(value.ordinal + 1)
    }
}







sealed class EncryptionException(message: String): Exception(message) {
        
        class Generic(message: String) : EncryptionException(message)
        

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<EncryptionException> {
        override fun lift(error_buf: RustBuffer.ByValue): EncryptionException = FfiConverterTypeEncryptionError.lift(error_buf)
    }
}

public object FfiConverterTypeEncryptionError : FfiConverterRustBuffer<EncryptionException> {
    override fun read(buf: ByteBuffer): EncryptionException {
        
            return when(buf.getInt()) {
            1 -> EncryptionException.Generic(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
        
    }

    override fun allocationSize(value: EncryptionException): Int {
        return 4
    }

    override fun write(value: EncryptionException, buf: ByteBuffer) {
        when(value) {
            is EncryptionException.Generic -> {
                buf.putInt(1)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}





sealed class KeyException(message: String): Exception(message) {
        
        class InvalidKeypair(message: String) : KeyException(message)
        
        class InvalidMnemonic(message: String) : KeyException(message)
        
        class DerivationPath(message: String) : KeyException(message)
        
        class PrivateKey(message: String) : KeyException(message)
        
        class PublicKey(message: String) : KeyException(message)
        
        class Generic(message: String) : KeyException(message)
        

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<KeyException> {
        override fun lift(error_buf: RustBuffer.ByValue): KeyException = FfiConverterTypeKeyError.lift(error_buf)
    }
}

public object FfiConverterTypeKeyError : FfiConverterRustBuffer<KeyException> {
    override fun read(buf: ByteBuffer): KeyException {
        
            return when(buf.getInt()) {
            1 -> KeyException.InvalidKeypair(FfiConverterString.read(buf))
            2 -> KeyException.InvalidMnemonic(FfiConverterString.read(buf))
            3 -> KeyException.DerivationPath(FfiConverterString.read(buf))
            4 -> KeyException.PrivateKey(FfiConverterString.read(buf))
            5 -> KeyException.PublicKey(FfiConverterString.read(buf))
            6 -> KeyException.Generic(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
        
    }

    override fun allocationSize(value: KeyException): Int {
        return 4
    }

    override fun write(value: KeyException, buf: ByteBuffer) {
        when(value) {
            is KeyException.InvalidKeypair -> {
                buf.putInt(1)
                Unit
            }
            is KeyException.InvalidMnemonic -> {
                buf.putInt(2)
                Unit
            }
            is KeyException.DerivationPath -> {
                buf.putInt(3)
                Unit
            }
            is KeyException.PrivateKey -> {
                buf.putInt(4)
                Unit
            }
            is KeyException.PublicKey -> {
                buf.putInt(5)
                Unit
            }
            is KeyException.Generic -> {
                buf.putInt(6)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class SolanaTransactionType {
    
    object Legacy : SolanaTransactionType()
    
    
    object Versioned : SolanaTransactionType()
    
    

    
    companion object
}

public object FfiConverterTypeSolanaTransactionType : FfiConverterRustBuffer<SolanaTransactionType>{
    override fun read(buf: ByteBuffer): SolanaTransactionType {
        return when(buf.getInt()) {
            1 -> SolanaTransactionType.Legacy
            2 -> SolanaTransactionType.Versioned
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: SolanaTransactionType) = when(value) {
        is SolanaTransactionType.Legacy -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
        is SolanaTransactionType.Versioned -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
    }

    override fun write(value: SolanaTransactionType, buf: ByteBuffer) {
        when(value) {
            is SolanaTransactionType.Legacy -> {
                buf.putInt(1)
                Unit
            }
            is SolanaTransactionType.Versioned -> {
                buf.putInt(2)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class TokenDestination {
    
    data class Account(
        
        val `transferDestination`: String
        ) : TokenDestination() {
        companion object
    }
    
    data class Wallet(
        
        val `publicKey`: ChainPublicKey
        ) : TokenDestination() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeTokenDestination : FfiConverterRustBuffer<TokenDestination>{
    override fun read(buf: ByteBuffer): TokenDestination {
        return when(buf.getInt()) {
            1 -> TokenDestination.Account(
                FfiConverterString.read(buf),
                )
            2 -> TokenDestination.Wallet(
                FfiConverterTypeChainPublicKey.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TokenDestination) = when(value) {
        is TokenDestination.Account -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterString.allocationSize(value.`transferDestination`)
            )
        }
        is TokenDestination.Wallet -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeChainPublicKey.allocationSize(value.`publicKey`)
            )
        }
    }

    override fun write(value: TokenDestination, buf: ByteBuffer) {
        when(value) {
            is TokenDestination.Account -> {
                buf.putInt(1)
                FfiConverterString.write(value.`transferDestination`, buf)
                Unit
            }
            is TokenDestination.Wallet -> {
                buf.putInt(2)
                FfiConverterTypeChainPublicKey.write(value.`publicKey`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class TransactionData {
    
    object Solana : TransactionData()
    
    

    
    companion object
}

public object FfiConverterTypeTransactionData : FfiConverterRustBuffer<TransactionData>{
    override fun read(buf: ByteBuffer): TransactionData {
        return when(buf.getInt()) {
            1 -> TransactionData.Solana
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TransactionData) = when(value) {
        is TransactionData.Solana -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
            )
        }
    }

    override fun write(value: TransactionData, buf: ByteBuffer) {
        when(value) {
            is TransactionData.Solana -> {
                buf.putInt(1)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}







sealed class TransactionException(message: String): Exception(message) {
        
        class KeyPair(message: String) : TransactionException(message)
        
        class SignerMissing(message: String) : TransactionException(message)
        
        class MultipleSigners(message: String) : TransactionException(message)
        
        class PrivateKey(message: String) : TransactionException(message)
        
        class PublicKey(message: String) : TransactionException(message)
        
        class Parameters(message: String) : TransactionException(message)
        
        class ParsingFailure(message: String) : TransactionException(message)
        
        class InstructionException(message: String) : TransactionException(message)
        
        class DecimalConversion(message: String) : TransactionException(message)
        
        class SignMsgException(message: String) : TransactionException(message)
        
        class Generic(message: String) : TransactionException(message)
        

    companion object ErrorHandler : UniffiRustCallStatusErrorHandler<TransactionException> {
        override fun lift(error_buf: RustBuffer.ByValue): TransactionException = FfiConverterTypeTransactionError.lift(error_buf)
    }
}

public object FfiConverterTypeTransactionError : FfiConverterRustBuffer<TransactionException> {
    override fun read(buf: ByteBuffer): TransactionException {
        
            return when(buf.getInt()) {
            1 -> TransactionException.KeyPair(FfiConverterString.read(buf))
            2 -> TransactionException.SignerMissing(FfiConverterString.read(buf))
            3 -> TransactionException.MultipleSigners(FfiConverterString.read(buf))
            4 -> TransactionException.PrivateKey(FfiConverterString.read(buf))
            5 -> TransactionException.PublicKey(FfiConverterString.read(buf))
            6 -> TransactionException.Parameters(FfiConverterString.read(buf))
            7 -> TransactionException.ParsingFailure(FfiConverterString.read(buf))
            8 -> TransactionException.InstructionException(FfiConverterString.read(buf))
            9 -> TransactionException.DecimalConversion(FfiConverterString.read(buf))
            10 -> TransactionException.SignMsgException(FfiConverterString.read(buf))
            11 -> TransactionException.Generic(FfiConverterString.read(buf))
            else -> throw RuntimeException("invalid error enum value, something is very wrong!!")
        }
        
    }

    override fun allocationSize(value: TransactionException): Int {
        return 4
    }

    override fun write(value: TransactionException, buf: ByteBuffer) {
        when(value) {
            is TransactionException.KeyPair -> {
                buf.putInt(1)
                Unit
            }
            is TransactionException.SignerMissing -> {
                buf.putInt(2)
                Unit
            }
            is TransactionException.MultipleSigners -> {
                buf.putInt(3)
                Unit
            }
            is TransactionException.PrivateKey -> {
                buf.putInt(4)
                Unit
            }
            is TransactionException.PublicKey -> {
                buf.putInt(5)
                Unit
            }
            is TransactionException.Parameters -> {
                buf.putInt(6)
                Unit
            }
            is TransactionException.ParsingFailure -> {
                buf.putInt(7)
                Unit
            }
            is TransactionException.InstructionException -> {
                buf.putInt(8)
                Unit
            }
            is TransactionException.DecimalConversion -> {
                buf.putInt(9)
                Unit
            }
            is TransactionException.SignMsgException -> {
                buf.putInt(10)
                Unit
            }
            is TransactionException.Generic -> {
                buf.putInt(11)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }

}



sealed class TransactionKind {
    
    data class Token(
        
        val `amount`: DecimalNumber, 
        
        val `closeAccount`: Boolean
        ) : TransactionKind() {
        companion object
    }
    
    data class Nft(
        
        val `amount`: ULong, 
        
        val `id`: String?
        ) : TransactionKind() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeTransactionKind : FfiConverterRustBuffer<TransactionKind>{
    override fun read(buf: ByteBuffer): TransactionKind {
        return when(buf.getInt()) {
            1 -> TransactionKind.Token(
                FfiConverterTypeDecimalNumber.read(buf),
                FfiConverterBoolean.read(buf),
                )
            2 -> TransactionKind.Nft(
                FfiConverterULong.read(buf),
                FfiConverterOptionalString.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TransactionKind) = when(value) {
        is TransactionKind.Token -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterTypeDecimalNumber.allocationSize(value.`amount`)
                + FfiConverterBoolean.allocationSize(value.`closeAccount`)
            )
        }
        is TransactionKind.Nft -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterULong.allocationSize(value.`amount`)
                + FfiConverterOptionalString.allocationSize(value.`id`)
            )
        }
    }

    override fun write(value: TransactionKind, buf: ByteBuffer) {
        when(value) {
            is TransactionKind.Token -> {
                buf.putInt(1)
                FfiConverterTypeDecimalNumber.write(value.`amount`, buf)
                FfiConverterBoolean.write(value.`closeAccount`, buf)
                Unit
            }
            is TransactionKind.Nft -> {
                buf.putInt(2)
                FfiConverterULong.write(value.`amount`, buf)
                FfiConverterOptionalString.write(value.`id`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}





sealed class TransactionParameters {
    
    data class Solana(
        
        val `externalAddress`: ExternalAddress?, 
        
        val `transactionType`: SolanaTransactionType, 
        
        val `ownerProgram`: String?, 
        
        val `decimals`: UByte?, 
        
        val `memo`: String?, 
        
        val `references`: List<String>, 
        
        val `swapSlippageBps`: UShort?, 
        
        val `computeBudgetUnitPrice`: ULong?, 
        
        val `computeBudgetUnitLimit`: UInt?
        ) : TransactionParameters() {
        companion object
    }
    

    
    companion object
}

public object FfiConverterTypeTransactionParameters : FfiConverterRustBuffer<TransactionParameters>{
    override fun read(buf: ByteBuffer): TransactionParameters {
        return when(buf.getInt()) {
            1 -> TransactionParameters.Solana(
                FfiConverterOptionalTypeExternalAddress.read(buf),
                FfiConverterTypeSolanaTransactionType.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterOptionalUByte.read(buf),
                FfiConverterOptionalString.read(buf),
                FfiConverterSequenceString.read(buf),
                FfiConverterOptionalUShort.read(buf),
                FfiConverterOptionalULong.read(buf),
                FfiConverterOptionalUInt.read(buf),
                )
            else -> throw RuntimeException("invalid enum value, something is very wrong!!")
        }
    }

    override fun allocationSize(value: TransactionParameters) = when(value) {
        is TransactionParameters.Solana -> {
            // Add the size for the Int that specifies the variant plus the size needed for all fields
            (
                4
                + FfiConverterOptionalTypeExternalAddress.allocationSize(value.`externalAddress`)
                + FfiConverterTypeSolanaTransactionType.allocationSize(value.`transactionType`)
                + FfiConverterOptionalString.allocationSize(value.`ownerProgram`)
                + FfiConverterOptionalUByte.allocationSize(value.`decimals`)
                + FfiConverterOptionalString.allocationSize(value.`memo`)
                + FfiConverterSequenceString.allocationSize(value.`references`)
                + FfiConverterOptionalUShort.allocationSize(value.`swapSlippageBps`)
                + FfiConverterOptionalULong.allocationSize(value.`computeBudgetUnitPrice`)
                + FfiConverterOptionalUInt.allocationSize(value.`computeBudgetUnitLimit`)
            )
        }
    }

    override fun write(value: TransactionParameters, buf: ByteBuffer) {
        when(value) {
            is TransactionParameters.Solana -> {
                buf.putInt(1)
                FfiConverterOptionalTypeExternalAddress.write(value.`externalAddress`, buf)
                FfiConverterTypeSolanaTransactionType.write(value.`transactionType`, buf)
                FfiConverterOptionalString.write(value.`ownerProgram`, buf)
                FfiConverterOptionalUByte.write(value.`decimals`, buf)
                FfiConverterOptionalString.write(value.`memo`, buf)
                FfiConverterSequenceString.write(value.`references`, buf)
                FfiConverterOptionalUShort.write(value.`swapSlippageBps`, buf)
                FfiConverterOptionalULong.write(value.`computeBudgetUnitPrice`, buf)
                FfiConverterOptionalUInt.write(value.`computeBudgetUnitLimit`, buf)
                Unit
            }
        }.let { /* this makes the `when` an expression, which ensures it is exhaustive */ }
    }
}






public object FfiConverterOptionalUByte: FfiConverterRustBuffer<UByte?> {
    override fun read(buf: ByteBuffer): UByte? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterUByte.read(buf)
    }

    override fun allocationSize(value: UByte?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterUByte.allocationSize(value)
        }
    }

    override fun write(value: UByte?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterUByte.write(value, buf)
        }
    }
}




public object FfiConverterOptionalUShort: FfiConverterRustBuffer<UShort?> {
    override fun read(buf: ByteBuffer): UShort? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterUShort.read(buf)
    }

    override fun allocationSize(value: UShort?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterUShort.allocationSize(value)
        }
    }

    override fun write(value: UShort?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterUShort.write(value, buf)
        }
    }
}




public object FfiConverterOptionalUInt: FfiConverterRustBuffer<UInt?> {
    override fun read(buf: ByteBuffer): UInt? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterUInt.read(buf)
    }

    override fun allocationSize(value: UInt?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterUInt.allocationSize(value)
        }
    }

    override fun write(value: UInt?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterUInt.write(value, buf)
        }
    }
}




public object FfiConverterOptionalULong: FfiConverterRustBuffer<ULong?> {
    override fun read(buf: ByteBuffer): ULong? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterULong.read(buf)
    }

    override fun allocationSize(value: ULong?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterULong.allocationSize(value)
        }
    }

    override fun write(value: ULong?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterULong.write(value, buf)
        }
    }
}




public object FfiConverterOptionalString: FfiConverterRustBuffer<String?> {
    override fun read(buf: ByteBuffer): String? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterString.read(buf)
    }

    override fun allocationSize(value: String?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterString.allocationSize(value)
        }
    }

    override fun write(value: String?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterString.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeChainPrivateKey: FfiConverterRustBuffer<ChainPrivateKey?> {
    override fun read(buf: ByteBuffer): ChainPrivateKey? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeChainPrivateKey.read(buf)
    }

    override fun allocationSize(value: ChainPrivateKey?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeChainPrivateKey.allocationSize(value)
        }
    }

    override fun write(value: ChainPrivateKey?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeChainPrivateKey.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeChainPublicKey: FfiConverterRustBuffer<ChainPublicKey?> {
    override fun read(buf: ByteBuffer): ChainPublicKey? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeChainPublicKey.read(buf)
    }

    override fun allocationSize(value: ChainPublicKey?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeChainPublicKey.allocationSize(value)
        }
    }

    override fun write(value: ChainPublicKey?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeChainPublicKey.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeExternalAddress: FfiConverterRustBuffer<ExternalAddress?> {
    override fun read(buf: ByteBuffer): ExternalAddress? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeExternalAddress.read(buf)
    }

    override fun allocationSize(value: ExternalAddress?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeExternalAddress.allocationSize(value)
        }
    }

    override fun write(value: ExternalAddress?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeExternalAddress.write(value, buf)
        }
    }
}




public object FfiConverterOptionalTypeTransactionParameters: FfiConverterRustBuffer<TransactionParameters?> {
    override fun read(buf: ByteBuffer): TransactionParameters? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterTypeTransactionParameters.read(buf)
    }

    override fun allocationSize(value: TransactionParameters?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterTypeTransactionParameters.allocationSize(value)
        }
    }

    override fun write(value: TransactionParameters?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterTypeTransactionParameters.write(value, buf)
        }
    }
}




public object FfiConverterOptionalSequenceString: FfiConverterRustBuffer<List<String>?> {
    override fun read(buf: ByteBuffer): List<String>? {
        if (buf.get().toInt() == 0) {
            return null
        }
        return FfiConverterSequenceString.read(buf)
    }

    override fun allocationSize(value: List<String>?): Int {
        if (value == null) {
            return 1
        } else {
            return 1 + FfiConverterSequenceString.allocationSize(value)
        }
    }

    override fun write(value: List<String>?, buf: ByteBuffer) {
        if (value == null) {
            buf.put(0)
        } else {
            buf.put(1)
            FfiConverterSequenceString.write(value, buf)
        }
    }
}




public object FfiConverterSequenceString: FfiConverterRustBuffer<List<String>> {
    override fun read(buf: ByteBuffer): List<String> {
        val len = buf.getInt()
        return List<String>(len) {
            FfiConverterString.read(buf)
        }
    }

    override fun allocationSize(value: List<String>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterString.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<String>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterString.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeChainPrivateKey: FfiConverterRustBuffer<List<ChainPrivateKey>> {
    override fun read(buf: ByteBuffer): List<ChainPrivateKey> {
        val len = buf.getInt()
        return List<ChainPrivateKey>(len) {
            FfiConverterTypeChainPrivateKey.read(buf)
        }
    }

    override fun allocationSize(value: List<ChainPrivateKey>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeChainPrivateKey.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ChainPrivateKey>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeChainPrivateKey.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeChainPublicKey: FfiConverterRustBuffer<List<ChainPublicKey>> {
    override fun read(buf: ByteBuffer): List<ChainPublicKey> {
        val len = buf.getInt()
        return List<ChainPublicKey>(len) {
            FfiConverterTypeChainPublicKey.read(buf)
        }
    }

    override fun allocationSize(value: List<ChainPublicKey>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeChainPublicKey.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<ChainPublicKey>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeChainPublicKey.write(it, buf)
        }
    }
}




public object FfiConverterSequenceTypeDerivedPrivateKey: FfiConverterRustBuffer<List<DerivedPrivateKey>> {
    override fun read(buf: ByteBuffer): List<DerivedPrivateKey> {
        val len = buf.getInt()
        return List<DerivedPrivateKey>(len) {
            FfiConverterTypeDerivedPrivateKey.read(buf)
        }
    }

    override fun allocationSize(value: List<DerivedPrivateKey>): Int {
        val sizeForLength = 4
        val sizeForItems = value.map { FfiConverterTypeDerivedPrivateKey.allocationSize(it) }.sum()
        return sizeForLength + sizeForItems
    }

    override fun write(value: List<DerivedPrivateKey>, buf: ByteBuffer) {
        buf.putInt(value.size)
        value.forEach {
            FfiConverterTypeDerivedPrivateKey.write(it, buf)
        }
    }
}
@Throws(TransactionException::class)

fun `appendSignatureToTransaction`(`signer`: String, `signature`: String, `transaction`: String): String {
    return FfiConverterString.lift(
    uniffiRustCallWithError(TransactionException) { _status ->
    UniffiLib.INSTANCE.uniffi_chainkit_fn_func_append_signature_to_transaction(FfiConverterString.lower(`signer`),FfiConverterString.lower(`signature`),FfiConverterString.lower(`transaction`),_status)
})
}

@Throws(EncryptionException::class)

fun `decryptCiphertext`(`ciphertext`: String, `password`: String): String {
    return FfiConverterString.lift(
    uniffiRustCallWithError(EncryptionException) { _status ->
    UniffiLib.INSTANCE.uniffi_chainkit_fn_func_decrypt_ciphertext(FfiConverterString.lower(`ciphertext`),FfiConverterString.lower(`password`),_status)
})
}

@Throws(KeyException::class)

fun `derive`(`chain`: Blockchain, `mnemonic`: MnemonicWords, `passphrase`: String?, `derivation`: Derivation): List<DerivedPrivateKey> {
    return FfiConverterSequenceTypeDerivedPrivateKey.lift(
    uniffiRustCallWithError(KeyException) { _status ->
    UniffiLib.INSTANCE.uniffi_chainkit_fn_func_derive(FfiConverterTypeBlockchain.lower(`chain`),FfiConverterTypeMnemonicWords.lower(`mnemonic`),FfiConverterOptionalString.lower(`passphrase`),FfiConverterTypeDerivation.lower(`derivation`),_status)
})
}

@Throws(KeyException::class)

fun `deriveFromData`(`chain`: Blockchain, `data`: String): DerivedPrivateKey {
    return FfiConverterTypeDerivedPrivateKey.lift(
    uniffiRustCallWithError(KeyException) { _status ->
    UniffiLib.INSTANCE.uniffi_chainkit_fn_func_derive_from_data(FfiConverterTypeBlockchain.lower(`chain`),FfiConverterString.lower(`data`),_status)
})
}

@Throws(EncryptionException::class)

fun `encryptPlaintext`(`plaintext`: String, `password`: String): String {
    return FfiConverterString.lift(
    uniffiRustCallWithError(EncryptionException) { _status ->
    UniffiLib.INSTANCE.uniffi_chainkit_fn_func_encrypt_plaintext(FfiConverterString.lower(`plaintext`),FfiConverterString.lower(`password`),_status)
})
}

@Throws(KeyException::class)

fun `generateMnemonic`(`length`: UInt): MnemonicWords {
    return FfiConverterTypeMnemonicWords.lift(
    uniffiRustCallWithError(KeyException) { _status ->
    UniffiLib.INSTANCE.uniffi_chainkit_fn_func_generate_mnemonic(FfiConverterUInt.lower(`length`),_status)
})
}

@Throws(TransactionException::class)

fun `getAssociatedTokenAddress`(`walletAddress`: String, `ownerProgram`: String, `tokenMintAddress`: String): ChainPublicKey {
    return FfiConverterTypeChainPublicKey.lift(
    uniffiRustCallWithError(TransactionException) { _status ->
    UniffiLib.INSTANCE.uniffi_chainkit_fn_func_get_associated_token_address(FfiConverterString.lower(`walletAddress`),FfiConverterString.lower(`ownerProgram`),FfiConverterString.lower(`tokenMintAddress`),_status)
})
}

@Throws(TransactionException::class)

fun `getMessage`(`transaction`: String): String {
    return FfiConverterString.lift(
    uniffiRustCallWithError(TransactionException) { _status ->
    UniffiLib.INSTANCE.uniffi_chainkit_fn_func_get_message(FfiConverterString.lower(`transaction`),_status)
})
}

@Throws(TransactionException::class)

fun `getProgramAddress`(`seeds`: List<String>, `program`: String): ChainPublicKey {
    return FfiConverterTypeChainPublicKey.lift(
    uniffiRustCallWithError(TransactionException) { _status ->
    UniffiLib.INSTANCE.uniffi_chainkit_fn_func_get_program_address(FfiConverterSequenceString.lower(`seeds`),FfiConverterString.lower(`program`),_status)
})
}


fun `isValid`(`chain`: Blockchain, `address`: String): Boolean {
    return FfiConverterBoolean.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_chainkit_fn_func_is_valid(FfiConverterTypeBlockchain.lower(`chain`),FfiConverterString.lower(`address`),_status)
})
}

@Throws(TransactionException::class)

fun `modifyTransaction`(`chain`: Blockchain, `transaction`: String, `owner`: ChainPrivateKey, `parameters`: TransactionParameters): String {
    return FfiConverterString.lift(
    uniffiRustCallWithError(TransactionException) { _status ->
    UniffiLib.INSTANCE.uniffi_chainkit_fn_func_modify_transaction(FfiConverterTypeBlockchain.lower(`chain`),FfiConverterString.lower(`transaction`),FfiConverterTypeChainPrivateKey.lower(`owner`),FfiConverterTypeTransactionParameters.lower(`parameters`),_status)
})
}


fun `parsePrivateKey`(`key`: String): ChainPrivateKey? {
    return FfiConverterOptionalTypeChainPrivateKey.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_chainkit_fn_func_parse_private_key(FfiConverterString.lower(`key`),_status)
})
}


fun `parsePublicKey`(`address`: String): ChainPublicKey? {
    return FfiConverterOptionalTypeChainPublicKey.lift(
    uniffiRustCall() { _status ->
    UniffiLib.INSTANCE.uniffi_chainkit_fn_func_parse_public_key(FfiConverterString.lower(`address`),_status)
})
}

@Throws(TransactionException::class)

fun `parseTransaction`(`chain`: Blockchain, `transaction`: String): ParsedTransaction {
    return FfiConverterTypeParsedTransaction.lift(
    uniffiRustCallWithError(TransactionException) { _status ->
    UniffiLib.INSTANCE.uniffi_chainkit_fn_func_parse_transaction(FfiConverterTypeBlockchain.lower(`chain`),FfiConverterString.lower(`transaction`),_status)
})
}

@Throws(KeyException::class)

fun `rawPrivateKey`(`chain`: Blockchain, `key`: String): ChainPrivateKey {
    return FfiConverterTypeChainPrivateKey.lift(
    uniffiRustCallWithError(KeyException) { _status ->
    UniffiLib.INSTANCE.uniffi_chainkit_fn_func_raw_private_key(FfiConverterTypeBlockchain.lower(`chain`),FfiConverterString.lower(`key`),_status)
})
}

@Throws(TransactionException::class)

fun `sendTransaction`(`chain`: Blockchain, `sender`: ChainPublicKey, `receiver`: ChainPublicKey, `amount`: DecimalNumber, `parameters`: TransactionParameters): String {
    return FfiConverterString.lift(
    uniffiRustCallWithError(TransactionException) { _status ->
    UniffiLib.INSTANCE.uniffi_chainkit_fn_func_send_transaction(FfiConverterTypeBlockchain.lower(`chain`),FfiConverterTypeChainPublicKey.lower(`sender`),FfiConverterTypeChainPublicKey.lower(`receiver`),FfiConverterTypeDecimalNumber.lower(`amount`),FfiConverterTypeTransactionParameters.lower(`parameters`),_status)
})
}

@Throws(TransactionException::class)

fun `signMessage`(`chain`: Blockchain, `message`: String, `signers`: List<ChainPrivateKey>): String {
    return FfiConverterString.lift(
    uniffiRustCallWithError(TransactionException) { _status ->
    UniffiLib.INSTANCE.uniffi_chainkit_fn_func_sign_message(FfiConverterTypeBlockchain.lower(`chain`),FfiConverterString.lower(`message`),FfiConverterSequenceTypeChainPrivateKey.lower(`signers`),_status)
})
}

@Throws(TransactionException::class)

fun `signTransaction`(`chain`: Blockchain, `transaction`: String, `signers`: List<ChainPrivateKey>, `parameters`: TransactionParameters?): ChainTransaction {
    return FfiConverterTypeChainTransaction.lift(
    uniffiRustCallWithError(TransactionException) { _status ->
    UniffiLib.INSTANCE.uniffi_chainkit_fn_func_sign_transaction(FfiConverterTypeBlockchain.lower(`chain`),FfiConverterString.lower(`transaction`),FfiConverterSequenceTypeChainPrivateKey.lower(`signers`),FfiConverterOptionalTypeTransactionParameters.lower(`parameters`),_status)
})
}

@Throws(TransactionException::class)

fun `signTypedData`(`chain`: Blockchain, `typedData`: String, `signers`: List<ChainPrivateKey>): String {
    return FfiConverterString.lift(
    uniffiRustCallWithError(TransactionException) { _status ->
    UniffiLib.INSTANCE.uniffi_chainkit_fn_func_sign_typed_data(FfiConverterTypeBlockchain.lower(`chain`),FfiConverterString.lower(`typedData`),FfiConverterSequenceTypeChainPrivateKey.lower(`signers`),_status)
})
}

@Throws(TransactionException::class)

fun `tokenTransaction`(`chain`: Blockchain, `destination`: TokenDestination, `owner`: ChainPublicKey, `token`: ChainPublicKey, `kind`: TransactionKind, `parameters`: TransactionParameters): String {
    return FfiConverterString.lift(
    uniffiRustCallWithError(TransactionException) { _status ->
    UniffiLib.INSTANCE.uniffi_chainkit_fn_func_token_transaction(FfiConverterTypeBlockchain.lower(`chain`),FfiConverterTypeTokenDestination.lower(`destination`),FfiConverterTypeChainPublicKey.lower(`owner`),FfiConverterTypeChainPublicKey.lower(`token`),FfiConverterTypeTransactionKind.lower(`kind`),FfiConverterTypeTransactionParameters.lower(`parameters`),_status)
})
}


